# Indices settings
Indices:
  # Subjects index
  - index_name: subjects
    type: neo4j
    # type mapping for each property of the index
    mapping:
      # Filter properties
      accesses:
        type: keyword
      acl:
        type: keyword
      experimental_strategies:
        type: keyword
      file_types:
        type: keyword
      genders:
        type: keyword
      image_modality:
        type: keyword
      instrument_models:
        type: keyword
      is_tumor:
        type: keyword
      library_layouts:
        type: keyword
      library_selections:
        type: keyword
      library_sources:
        type: keyword
      library_strategies:
        type: keyword
      number_of_study_participants:
        type: integer
      number_of_study_samples:
        type: integer
      phs_accession:
        type: keyword
      platforms:
        type: keyword
      primary_diagnoses:
        type: keyword
      reference_genome_assemblies:
        type: keyword
      sample_types:
        type: keyword
      site:
        type: keyword
      studies:
        type: keyword
      study_data_types:
        type: keyword
      # Sort properties
      is_tumor_sort:
        type: keyword
      sample_types_sort:
        type: keyword
      experimental_strategies_sort:
        type: keyword
      file_types_sort:
        type: keyword
      primary_diagnoses_sort:
        type: keyword
      site_sort:
        type: keyword
      library_layouts_sort:
        type: keyword
      library_selections_sort:
        type: keyword
      library_sources_sort:
        type: keyword
      library_strategies_sort:
        type: keyword
      instrument_models_sort:
        type: keyword
      platforms_sort:
        type: keyword
      reference_genome_assemblies_sort:
        type: keyword
      image_modality_sort:
        type: keyword
      # Global Search properties
      site_gs:
        type: search_as_you_type
      study_gs:
        type: search_as_you_type
      subject_id_gs:
        type: search_as_you_type
      gender_gs:
        type: search_as_you_type
      # Overview properties
      participant_id:
        type: keyword
      race:
        type: keyword
      gender:
        type: keyword
      ethnicity:
        type: keyword
      dbGaP_subject_id:
        type: keyword
      files:
        type: keyword
      samples:
        type: keyword
      subject_ids:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      WITH 'Not specified in data' AS na
      MATCH (s:study)<--(f:file)
      OPTIONAL MATCH (f)-->(p:participant)
      WITH s, na,
        {
          accesses: apoc.coll.sort(COLLECT(DISTINCT COALESCE(s.study_access, na))),
          acl: apoc.coll.sort(COLLECT(DISTINCT COALESCE(s.acl, na))),
          phs_accession: apoc.coll.sort(COLLECT(DISTINCT COALESCE(s.phs_accession, na))),
          studies: apoc.coll.sort(COLLECT(DISTINCT COALESCE(s.study_name, na))),
          study_data_types: apoc.coll.sort(COLLECT(DISTINCT COALESCE(s.study_data_types, na))),
          number_of_study_participants: count(distinct p),
          study_gs: apoc.coll.sort(COLLECT(DISTINCT COALESCE(s.study_name, na)))
        } AS opensearch_data
      MATCH (s:study)<--(f:file)
      OPTIONAL MATCH (f)-->(p:participant)
      OPTIONAL MATCH (p)<--(samp:sample)
      WITH s, na,
        apoc.map.merge(opensearch_data, {
          number_of_study_samples: count(distinct samp)
        }) AS opensearch_data
      MATCH (s)<--(:file)-->(p:participant)
      WITH DISTINCT p, na, opensearch_data
      SKIP $skip LIMIT $limit
      WITH p, na,
        apoc.map.merge(opensearch_data, {
          participant_id: COALESCE(p.participant_id, na),
          gender: COALESCE(p.gender, na),
          genders: COALESCE(p.gender, na),
          ethnicity: COALESCE(p.ethnicity, na),
          race: COALESCE(p.race, na),
          subject_ids: p.participant_id,
          dbGaP_subject_id: COALESCE(p.dbGaP_subject_id, na)
        }) AS opensearch_data
      WITH p, na, 
        apoc.map.merge(opensearch_data, {
          gender_gs: opensearch_data.genders,
          subject_id_gs: opensearch_data.subject_ids
        }) AS opensearch_data
      OPTIONAL MATCH (p)<--(samp:sample)
      WITH p, na, opensearch_data,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_tumor_status, na))) AS is_tumor,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_id, na))) AS samples,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(TRIM(LAST(apoc.text.split(samp.sample_type, ':'))), na))) AS sample_types
      WITH p, na,
        apoc.map.merge(opensearch_data, {
          is_tumor: is_tumor,
          samples: samples,
          sample_types: sample_types,
          is_tumor_sort: apoc.text.join(is_tumor, ''),
          sample_types_sort: apoc.text.join(sample_types, '')
        }) AS opensearch_data
      OPTIONAL MATCH (p)<--(f:file)
      WITH p, na, opensearch_data, 
          apoc.coll.sort(apoc.coll.toSet(f.experimental_strategy_and_data_subtypes)) AS experimental_strategies,
          apoc.coll.sort(COLLECT(DISTINCT COALESCE(f.file_type, na))) AS file_types,
          apoc.coll.sort(COLLECT(DISTINCT COALESCE(f.file_id, na))) AS files
      WITH p, na,
        apoc.map.merge(opensearch_data, {
          experimental_strategies: experimental_strategies,
          file_types: file_types,
          files: files,
          experimental_strategies_sort: apoc.text.join(experimental_strategies, ''),
          file_types_sort: apoc.text.join(file_types, '')
        }) AS opensearch_data
      OPTIONAL MATCH (p)<--(diag:diagnosis)
      WITH p, na, opensearch_data,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(diag.primary_site, na))) AS primary_site,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(TRIM(LAST(apoc.text.split(diag.primary_diagnosis, ':'))), na))) AS primary_diagnosis
      WITH p, na, 
        apoc.map.merge(opensearch_data, {
          primary_diagnoses: primary_diagnosis,
          site: primary_site,
          site_gs: primary_site,
          primary_diagnoses_sort: apoc.text.join(primary_diagnosis, ''),
          site_sort: apoc.text.join(primary_site, '')
        }) AS opensearch_data
      OPTIONAL MATCH (p)<--(f:file)
      OPTIONAL MATCH (f)<--(g:genomic_info)
      WITH p, na, opensearch_data,
          apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_layout, na))) AS library_layouts,
          apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_selection, na))) AS library_selections,
          apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_source, na))) AS library_sources, 
          apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_strategy, na))) AS library_strategies,
          apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.instrument_model, na))) AS instrument_models,
          apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.platform, na))) AS platforms,
          apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.reference_genome_assembly, na))) AS reference_genome_assemblies
      WITH p, na, 
        apoc.map.merge(opensearch_data, {
          library_layouts: library_layouts,
          library_selections: library_selections,
          library_sources: library_sources, 
          library_strategies: library_strategies,
          instrument_models: instrument_models,
          platforms: platforms,
          reference_genome_assemblies: reference_genome_assemblies,
          library_layouts_sort: apoc.text.join(library_layouts, ''),
          library_selections_sort: apoc.text.join(library_selections, ''),
          library_sources_sort: apoc.text.join(library_sources, ''), 
          library_strategies_sort: apoc.text.join(library_strategies, ''),
          instrument_models_sort: apoc.text.join(instrument_models, ''),
          platforms_sort: apoc.text.join(platforms, ''),
          reference_genome_assemblies_sort: apoc.text.join(reference_genome_assemblies, '')
        }) AS opensearch_data
      OPTIONAL MATCH (p)<--(f:file)
      OPTIONAL MATCH (f)<--(i:image)
      WITH p, na, opensearch_data, 
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(i.image_modality, na))) AS image_modality
      WITH p, na, 
        apoc.map.merge(opensearch_data, {
          image_modality: image_modality,
          image_modality_sort: apoc.text.join(image_modality, '')
        }) AS opensearch_data
      RETURN opensearch_data
      ORDER BY opensearch_data.subject_ids
      "
  # Samples index
  - index_name: samples
    type: neo4j
    mapping:
      # Filter properties
      accesses:
        type: keyword
      acl:
        type: keyword
      experimental_strategies:
        type: keyword
      file_types:
        type: keyword
      genders:
        type: keyword
      image_modality:
        type: keyword
      instrument_models:
        type: keyword
      is_tumor:
        type: keyword
      library_layouts:
        type: keyword
      library_selections:
        type: keyword
      library_sources:
        type: keyword
      library_strategies:
        type: keyword
      number_of_study_participants:
        type: integer
      number_of_study_samples:
        type: integer
      phs_accession:
        type: keyword
      platforms:
        type: keyword
      primary_diagnoses:
        type: keyword
      reference_genome_assemblies:
        type: keyword
      sample_types:
        type: keyword
      site:
        type: keyword
      studies:
        type: keyword
      study_data_types:
        type: keyword
      # Sort properties
      experimental_strategies_sort:
        type: keyword
      file_types_sort:
        type: keyword
      library_layouts_sort:
        type: keyword
      library_selections_sort:
        type: keyword
      library_sources_sort:
        type: keyword
      library_strategies_sort:
        type: keyword
      instrument_models_sort:
        type: keyword
      platforms_sort:
        type: keyword
      reference_genome_assemblies_sort:
        type: keyword
      primary_diagnoses_sort:
        type: keyword
      site_sort:
        type: keyword
      # Global search properties
      sample_id_gs:
        type: search_as_you_type
      is_tumor_gs:
        type: search_as_you_type
      analyte_type_gs:
        type: search_as_you_type
      # Overview properties
      analyte_type:
        type: keyword
      files:
        type: keyword
      sample_id:
        type: keyword
      sample_ids:
        type: keyword
      subject_ids:
        type: keyword
      organ_or_tissue:
        type: keyword
      sample_type:
        type: keyword
      sample_tumor_status:
        type: keyword
      sample_anatomic_site:
        type: keyword
      sample_age_at_collection:
        type: keyword
      derived_from_specimen:
        type: keyword
      biosample_accession:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      WITH 'Not specified in data' AS na
      MATCH (s:study)<--(f:file)
      OPTIONAL MATCH (f)-->(p:participant)
      WITH s, na,
        {
          accesses: apoc.coll.sort(COLLECT(DISTINCT COALESCE(s.study_access, na))),
          acl: apoc.coll.sort(COLLECT(DISTINCT COALESCE(s.acl, na))),
          phs_accession: apoc.coll.sort(COLLECT(DISTINCT COALESCE(s.phs_accession, na))),
          studies: apoc.coll.sort(COLLECT(DISTINCT COALESCE(s.study_name, na))),
          study_data_types: apoc.coll.sort(COLLECT(DISTINCT COALESCE(s.study_data_types, na))),
          number_of_study_participants: count(distinct p),
          study_gs: apoc.coll.sort(COLLECT(DISTINCT COALESCE(s.study_name, na)))
        } AS opensearch_data
      MATCH (s:study)<--(f:file)
      OPTIONAL MATCH (f)-->(p:participant)
      OPTIONAL MATCH (p)<--(samp:sample)
      WITH s, na,
        apoc.map.merge(opensearch_data, {
          number_of_study_samples: count(distinct samp)
        }) AS opensearch_data
      MATCH (s)<--(:file)-->(p:participant)<--(samp:sample)
      WITH DISTINCT samp, na, 
        apoc.map.merge(opensearch_data, {
          is_tumor: samp.sample_tumor_status,
          analyte_type: TRIM(LAST(apoc.text.split(samp.sample_type, ':'))),
          sample_types: TRIM(LAST(apoc.text.split(samp.sample_type, ':'))),
          sample_type: TRIM(LAST(apoc.text.split(samp.sample_type, ':'))),
          sample_id: samp.sample_id,
          sample_ids: samp.sample_id,
          sample_tumor_status: samp.sample_tumor_status,
          sample_anatomic_site: TRIM(LAST(apoc.text.split(samp.sample_anatomic_site, ':'))),
          sample_age_at_collection: samp.sample_age_at_collection,
          derived_from_specimen: samp.derived_from_specimen,
          biosample_accession: samp.biosample_accession
        }) AS opensearch_data
      SKIP $skip LIMIT $limit
      WITH samp, na, 
      apoc.map.merge(opensearch_data, {
          is_tumor_gs: opensearch_data.is_tumor,
          analyte_type_gs: opensearch_data.analyte_type,
          sample_id_gs: opensearch_data.sample_id
        }) AS opensearch_data
      OPTIONAL MATCH (samp)-->(p:participant)
      WITH samp, na, opensearch_data,
        COALESCE(p.gender, na) AS genders,
        COALESCE(p.participant_id, na) AS subject_ids
      WITH samp, na, 
        apoc.map.merge(opensearch_data, {
          genders: genders,
          subject_ids: subject_ids
        }) AS opensearch_data
      OPTIONAL MATCH (samp)-->(p:participant)
      OPTIONAL MATCH (p)<--(f:file)
      WITH samp, na, opensearch_data,
          apoc.coll.sort(apoc.coll.toSet(f.experimental_strategy_and_data_subtypes)) AS experimental_strategies,
          apoc.coll.sort(COLLECT(DISTINCT COALESCE(f.file_type, na))) AS file_types,
          apoc.coll.sort(COLLECT(DISTINCT COALESCE(f.file_id, na))) AS files
      WITH samp, na,
        apoc.map.merge(opensearch_data, {
          experimental_strategies: experimental_strategies,
          file_types: file_types,
          files: files,
          experimental_strategies_sort: apoc.text.join(experimental_strategies, ''),
          file_types_sort: apoc.text.join(file_types, '')
        }) AS opensearch_data
      OPTIONAL MATCH (samp)-->(p:participant)
      OPTIONAL MATCH (p)<--(f:file)
      OPTIONAL MATCH (f)<--(g:genomic_info)
      WITH samp, na, opensearch_data,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_layout, na))) AS library_layouts, 
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_selection, na))) AS library_selections, 
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_source, na))) AS library_sources, 
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_strategy, na))) AS library_strategies,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.instrument_model, na))) AS instrument_models,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.platform, na))) AS platforms,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.reference_genome_assembly, na))) AS reference_genome_assemblies
      WITH samp, na,
        apoc.map.merge(opensearch_data, {
          library_layouts: library_layouts, 
          library_selections: library_selections, 
          library_sources: library_sources, 
          library_strategies: library_strategies,
          instrument_models: reference_genome_assemblies,
          platforms: platforms,
          reference_genome_assemblies: reference_genome_assemblies,
          library_layouts_sort: apoc.text.join(library_layouts, ''),
          library_selections_sort: apoc.text.join(library_selections, ''),
          library_sources_sort: apoc.text.join(library_sources, ''),
          library_strategies_sort: apoc.text.join(library_strategies,''),
          instrument_models_sort: apoc.text.join(reference_genome_assemblies,''),
          platforms_sort: apoc.text.join(platforms,''),
          reference_genome_assemblies_sort: apoc.text.join(reference_genome_assemblies, '')
        }) AS opensearch_data
      OPTIONAL MATCH (samp)-->(p:participant)
      OPTIONAL MATCH (p)<--(diag:diagnosis)
      WITH samp, na, opensearch_data, 
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(TRIM(LAST(apoc.text.split(diag.primary_diagnosis, ':'))), na))) AS primary_diagnoses,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(diag.primary_site, na))) AS site
      WITH samp, na, 
        apoc.map.merge(opensearch_data, {
          primary_diagnoses: primary_diagnoses,
          site: site,
          primary_diagnoses_sort: apoc.text.join(primary_diagnoses, ''),
          site_sort: apoc.text.join(site, '')
        }) AS opensearch_data
      OPTIONAL MATCH (samp)-->(p:participant)
      OPTIONAL MATCH (p)<--(f:file)
      OPTIONAL MATCH (f)<--(i:image)
      WITH samp, na, opensearch_data,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(i.image_modality, na))) AS image_modality,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(i.organ_or_tissue, na))) AS organ_or_tissue
      WITH samp, na, 
        apoc.map.merge(opensearch_data, {
          image_modality: image_modality,
          organ_or_tissue: organ_or_tissue,
          image_modality_sort: apoc.text.join(image_modality, ''),
          organ_or_tissue_sort: apoc.text.join(organ_or_tissue, '')
        }) AS opensearch_data
      RETURN opensearch_data
      ORDER BY opensearch_data.sample_id
    "
  # Files index (split by experimental strategies)
  - index_name: file_experimental_strategies
    type: neo4j
    mapping:
      file_id:
        type: keyword
      # Filter properties
      accesses:
        type: keyword
      acl:
        type: keyword
      experimental_strategies:
        type: keyword
      file_types:
        type: keyword
      genders:
        type: keyword
      image_modality:
        type: keyword
      instrument_models:
        type: keyword
      is_tumor:
        type: keyword
      library_layouts:
        type: keyword
      library_selections:
        type: keyword
      library_sources:
        type: keyword
      library_strategies:
        type: keyword
      number_of_study_participants:
        type: integer
      number_of_study_samples:
        type: integer
      phs_accession:
        type: keyword
      platforms:
        type: keyword
      primary_diagnoses:
        type: keyword
      reference_genome_assemblies:
        type: keyword
      sample_types:
        type: keyword
      site:
        type: keyword
      studies:
        type: keyword
      study_data_types:
        type: keyword
    cypher_query: "
      MATCH (s:study)<--(f:file)
      OPTIONAL MATCH (f)-->(p:participant)
      WITH s,
        {
          accesses: s.study_access,
          acl: s.acl,
          phs_accession: s.phs_accession,
          studies: s.study_name,
          study_data_types: s.study_data_types,
          number_of_study_participants: count(distinct p),
          study_gs: s.study_name
        } AS opensearch_data
      MATCH (s:study)<--(f:file)
      OPTIONAL MATCH (f)-->(p:participant)
      OPTIONAL MATCH (p)<--(samp:sample)
      WITH s, 
        apoc.map.merge(opensearch_data, {
          number_of_study_samples: count(distinct samp)
        }) AS opensearch_data
      MATCH (s)<--(f:file)
      WITH DISTINCT f, 'Not specified in data' AS na, opensearch_data
      UNWIND f.experimental_strategy_and_data_subtypes AS experimental_strategies
      WITH f, na, opensearch_data, experimental_strategies, coalesce(toUpper(f.file_type), na) AS file_type
      SKIP $skip LIMIT $limit
      WITH f, na,
        apoc.map.merge(opensearch_data, {
          experimental_strategies: experimental_strategies,
          file_types: file_type ,
          files: f.file_id,
          file_id: f.file_id,
          file_name: f.file_name,
          file_type: file_type,
          file_size: f.file_size,
          md5sum: f.md5sum
        }) AS opensearch_data
      OPTIONAL MATCH (f)-->(p:participant)
      WITH f, na, opensearch_data, 
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(p.gender, na))) AS gender,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(p.participant_id, na))) AS participant_id
      WITH f, na,
        apoc.map.merge(opensearch_data, {
          genders: gender,
          subject_ids: participant_id
        }) AS opensearch_data
      OPTIONAL MATCH (f)-->(p:participant)
      OPTIONAL MATCH (p)<--(samp:sample)
      WITH f, na, opensearch_data,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_tumor_status, na))) AS sample_tumor_status,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(TRIM(LAST(apoc.text.split(samp.sample_type, ':'))), na))) AS sample_type,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_id, na))) AS sample_id
      WITH f, na,
        apoc.map.merge(opensearch_data, {
          is_tumor: sample_tumor_status,
          analyte_type: sample_type,
          sample_types: sample_type,
          sample_ids: sample_id
        }) AS opensearch_data
      OPTIONAL MATCH (f)<--(g:genomic_info)
      WITH f, na,
        apoc.map.merge(opensearch_data, {
          library_layouts: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_layout, na))), 
          library_selections: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_selection, na))), 
          library_sources: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_source, na))), 
          library_strategies: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_strategy, na))),
          instrument_models: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.instrument_model, na))),
          platforms: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.platform, na))),
          reference_genome_assemblies: apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.reference_genome_assembly, na)))
        }) AS opensearch_data
      OPTIONAL MATCH (f)-->(p:participant)
      OPTIONAL MATCH (p)<--(diag:diagnosis)
      WITH f, na, 
        apoc.map.merge(opensearch_data, {
          primary_diagnoses: apoc.coll.sort(COLLECT(DISTINCT COALESCE(TRIM(LAST(apoc.text.split(diag.primary_diagnosis, ':'))), na))),
          site: apoc.coll.sort(COLLECT(DISTINCT COALESCE(diag.primary_site, na)))
        }) AS opensearch_data
      OPTIONAL MATCH (f)<--(i:image)
      WITH f, na, 
        apoc.map.merge(opensearch_data, {
          image_modality: COALESCE(i.image_modality, na)
        }) AS opensearch_data
      RETURN opensearch_data
      ORDER BY opensearch_data.files
    "
  # Files index
  - index_name: files
    type: neo4j
    mapping:
      # Filter properties
      accesses:
        type: keyword
      acl:
        type: keyword
      experimental_strategies:
        type: keyword
      file_types:
        type: keyword
      genders:
        type: keyword
      races:
        type: keyword
      image_modality:
        type: keyword
      organ_or_tissue:
        type: keyword
      license:
        type: keyword
      instrument_models:
        type: keyword
      is_tumor:
        type: keyword
      library_layouts:
        type: keyword
      library_selections:
        type: keyword
      library_sources:
        type: keyword
      library_strategies:
        type: keyword
      number_of_study_participants:
        type: integer
      number_of_study_samples:
        type: integer
      phs_accession:
        type: keyword
      platforms:
        type: keyword
      primary_diagnoses:
        type: keyword
      reference_genome_assemblies:
        type: keyword
      sample_types:
        type: keyword
      site:
        type: keyword
      studies:
        type: keyword
      study_data_types:
        type: keyword
      # Overview properties
      analyte_type:
        type: keyword
      file_id:
        type: keyword
      file_ids:
        type: keyword
      file_name:
        type: keyword
      file_names:
        type: keyword
      file_type:
        type: keyword
      file_size:
        type: long
      md5sum:
        type: keyword
      file_url_in_cds:
        type: keyword
      sample_id:
        type: keyword
      sample_ids:
        type: keyword
      subject_ids:
        type: keyword
      file_description:
        type: keyword
      experimental_strategy_and_data_subtypes:
        type: keyword
      drs_uri:
        type: keyword
      # Sort properties
      analyte_type_sort:
        type: keyword
      experimental_strategies_sort:
        type: keyword
      genders_sort:
        type: keyword
      races_sort:
        type: keyword
      is_tumor_sort:
        type: keyword
      sample_types_sort:
        type: keyword
      library_layouts_sort:
        type: keyword
      library_selections_sort:
        type: keyword
      library_sources_sort:
        type: keyword
      library_strategies_sort:
        type: keyword
      instrument_models_sort:
        type: keyword
      platforms_sort:
        type: keyword
      primary_diagnoses_sort:
        type: keyword
      site_sort:
        type: keyword
      # Global search properties
      file_id_gs:
        type: search_as_you_type
      file_name_gs:
        type: search_as_you_type
      file_type_gs:
        type: search_as_you_type
      subject_id_gs:
        type: search_as_you_type
      sample_id_gs:
        type: search_as_you_type
      accesses_gs:
        type: search_as_you_type
      acl_gs:
        type: search_as_you_type
      experimental_strategies_gs:
        type: search_as_you_type
      instrument_models_gs:
        type: search_as_you_type
      library_layouts_gs:
        type: search_as_you_type
      library_selections_gs:
        type: search_as_you_type
      library_sources_gs:
        type: search_as_you_type
      library_strategies_gs:
        type: search_as_you_type
      platforms_gs:
        type: search_as_you_type
      reference_genome_assemblies_gs:
        type: search_as_you_type
      sites_gs:
        type: search_as_you_type
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (s:study)<--(f:file)
      OPTIONAL MATCH (f)-->(p:participant)
      WITH s,
        {
          accesses: s.study_access,
          accesses_gs: s.study_access,
          acl: s.acl,
          acl_gs: s.acl,
          phs_accession: s.phs_accession,
          studies: s.study_name,
          study_data_types: s.study_data_types,
          number_of_study_participants: count(distinct p),
          study_gs: s.study_name
        } AS opensearch_data
      MATCH (s:study)<--(f:file)
      OPTIONAL MATCH (f)-->(p:participant)
      OPTIONAL MATCH (p)<--(samp:sample)
      WITH s, 
        apoc.map.merge(opensearch_data, {
          number_of_study_samples: count(distinct samp)
        }) AS opensearch_data
      MATCH (s)<--(f:file)
      WITH DISTINCT f, 'Not specified in data' AS na, opensearch_data
      SKIP $skip LIMIT $limit
      WITH f, na, opensearch_data,
        coalesce(toUpper(f.file_type), na) AS file_type, 
        apoc.coll.sort(apoc.coll.toSet(f.experimental_strategy_and_data_subtypes)) AS experimental_strategy_and_data_subtypes
      WITH f, na, 
        apoc.map.merge(opensearch_data, {
          experimental_strategies: experimental_strategy_and_data_subtypes,
          experimental_strategies_sort: apoc.text.join(experimental_strategy_and_data_subtypes, ''),
          experimental_strategy_and_data_subtypes: f.experimental_strategy_and_data_subtypes,
          file_description: f.file_description,
          file_types: file_type ,
          files: f.file_id,
          file_id: f.file_id,
          file_ids: f.file_id,
          file_name: f.file_name,
          file_names: f.file_name,
          file_type: file_type,
          file_size: f.file_size,
          md5sum: f.md5sum,
          experimental_strategies_gs: experimental_strategy_and_data_subtypes,
          file_type_gs: f.file_type ,
          file_id_gs: f.file_id,
          file_name_gs: f.file_name,
          file_url_in_cds: f.file_url_in_cds,
          drs_uri: 'drs://nci-crdc.datacommons.io/' + f.file_id
        }) AS opensearch_data
      OPTIONAL MATCH (f)-->(p:participant)
      WITH f, na, opensearch_data,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(p.gender, na))) AS gender,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(p.race, na))) AS race,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(p.participant_id, na))) AS participant_id
      WITH f, na, 
        apoc.map.merge(opensearch_data, {
          genders: gender,
          genders_sort: apoc.text.join(gender, ''),
          races: race,
          races_sort: apoc.text.join(race, ''),
          subject_ids: participant_id,
          subject_id_gs: participant_id
        }) AS opensearch_data
      OPTIONAL MATCH (f)-->(p:participant)
      OPTIONAL MATCH (p)<--(samp:sample)
      WITH f, na, opensearch_data, 
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_tumor_status, na))) AS sample_tumor_status,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(TRIM(LAST(apoc.text.split(samp.sample_type, ':'))), na))) AS sample_type,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(samp.sample_id, na))) AS sample_id
      WITH f, na, 
        apoc.map.merge(opensearch_data, {
          is_tumor: sample_tumor_status,
          is_tumor_sort: apoc.text.join(sample_tumor_status, ''),
          sample_types: sample_type,
          sample_types_sort: apoc.text.join(sample_type, ''),
          analyte_type: sample_type,
          analyte_type_sort: apoc.text.join(sample_type, ''),
          sample_id: sample_id,
          sample_ids: sample_id,
          sample_id_gs: sample_id
        }) AS opensearch_data
      OPTIONAL MATCH (f)<--(g:genomic_info)
      WITH f, na, opensearch_data, 
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_layout, na))) AS library_layout,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_selection, na))) AS library_selection,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_source, na))) AS library_source,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.library_strategy, na))) AS library_strategy,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.instrument_model, na))) AS instrument_model,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.platform, na))) AS platform,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(g.reference_genome_assembly, na))) AS reference_genome_assembly
      WITH f, na,
        apoc.map.merge(opensearch_data, {
          library_layouts: library_layout, 
          library_selections: library_selection, 
          library_sources: library_source, 
          library_strategies: library_strategy,
          instrument_models: instrument_model,
          platforms: platform,
          reference_genome_assemblies: reference_genome_assembly,
          library_layouts_gs: library_layout, 
          library_selections_gs: library_selection, 
          library_sources_gs: library_source, 
          library_strategies_gs: library_strategy,
          instrument_models_gs: instrument_model,
          platforms_gs: platform,
          reference_genome_assemblies_gs: reference_genome_assembly,
          library_layouts_sort: apoc.text.join(library_layout, ''), 
          library_selections_sort: apoc.text.join(library_selection, ''), 
          library_sources_sort: apoc.text.join(library_source, ''), 
          library_strategies_sort: apoc.text.join(library_strategy, ''),
          instrument_models_sort: apoc.text.join(instrument_model, ''),
          platforms_sort: apoc.text.join(platform, ''),
          reference_genome_assemblies_sort: apoc.text.join(reference_genome_assembly, '')
        }) AS opensearch_data
      OPTIONAL MATCH (f)-->(p:participant)
      OPTIONAL MATCH (p)<--(diag:diagnosis)
      WITH f, na, opensearch_data,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(TRIM(LAST(apoc.text.split(diag.primary_diagnosis, ':'))), na))) AS primary_diagnosis,
        apoc.coll.sort(COLLECT(DISTINCT COALESCE(diag.primary_site, na))) AS primary_site
      WITH f, na, 
        apoc.map.merge(opensearch_data, {
          primary_diagnoses: primary_diagnosis,
          site: primary_site,
          sites_gs: primary_site,
          primary_diagnoses_sort: apoc.text.join(primary_diagnosis, ''),
          site_sort: apoc.text.join(primary_site, '')
        }) AS opensearch_data
      OPTIONAL MATCH (f)<--(i:image)
      WITH f, na, opensearch_data,
        COALESCE(i.image_modality, na) AS image_modality,
        COALESCE(i.organ_or_tissue, na) AS organ_or_tissue,
        COALESCE(i.license, na) AS license
      WITH f, na, image_modality,
        apoc.map.merge(opensearch_data, {
          image_modality: image_modality,
          organ_or_tissue: organ_or_tissue,
          license: license
        }) AS opensearch_data
      RETURN opensearch_data
      ORDER BY opensearch_data.files
    "
  # Programs index
  - index_name: programs
    type: neo4j
    # type mapping for each property of the index
    mapping:
      # program properties
      program_name:
        type: keyword
      program_acronym:
        type: keyword
      program_short_description:
        type: keyword
      program_full_description:
        type: keyword
      program_external_url:
        type: keyword
      program_sort_order:
        type: keyword
      # global search
      program_name_gs:
        type: search_as_you_type
      program_short_description_gs:
        type: search_as_you_type
      program_full_description_gs:
        type: search_as_you_type
      program_external_url_gs:
        type: search_as_you_type
      program_sort_order_gs:
        type: search_as_you_type
      type_gs:
        type: search_as_you_type
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (p:program)
      WITH p, 'program' as type_gs
      SKIP $skip LIMIT $limit
      RETURN
        p.program_name AS program_name,
        p.program_acronym AS program_acronym,
        p.program_short_description AS program_short_description,
        p.program_full_description AS program_full_description,
        p.program_external_url AS program_external_url,
        p.program_sort_order AS program_sort_order,
        p.program_name AS program_name_gs,
        p.program_short_description AS program_short_description_gs,
        p.program_full_description AS program_full_description_gs,
        p.program_external_url AS program_external_url_gs,
        p.program_sort_order AS program_sort_order_gs,
        type_gs
    "
  # Studies index
  - index_name: studies
    type: neo4j
    # type mapping for each property of the index
    mapping:
      study_name:
        type: keyword
      study_code:
        type: keyword
      study_acronym:
        type: keyword
      study_description:
        type: keyword
      short_description:
        type: keyword
      study_external_url:
        type: keyword
      primary_investigator_name:
        type: keyword
      primary_investigator_email:
        type: keyword
      co_investigator_name:
        type: keyword
      co_investigator_email:
        type: keyword
      phs_accession:
        type: keyword
      bioproject_accession:
        type: keyword
      index_date:
        type: keyword
      cds_requestor:
        type: keyword
      funding_agency:
        type: keyword
      funding_source_program_name:
        type: keyword
      grant_id:
        type: keyword
      clinical_trial_system:
        type: keyword
      clinical_trial_identifier:
        type: keyword
      clinical_trial_arm:
        type: keyword
      organism_species:
        type: keyword
      adult_or_childhood_study:
        type: keyword
      data_types:
        type: keyword
      file_types:
        type: keyword
      data_access_level:
        type: keyword
      cds_primary_bucket:
        type: keyword
      cds_secondary_bucket:
        type: keyword
      cds_tertiary_bucket:
        type: keyword
      number_of_participants:
        type: keyword
      number_of_samples:
        type: keyword
      study_data_types:
        type: keyword
      file_types_and_format:
        type: keyword
      size_of_data_being_uploaded:
        type: keyword
      size_of_data_being_uploaded_unit:
        type: keyword
      size_of_data_being_uploaded_original:
        type: keyword
      size_of_data_being_uploaded_original_unit:
        type: keyword
      acl:
        type: keyword
      study_access:
        type: keyword
      study_version:
        type: keyword
      study_code_gs:
        type: search_as_you_type
      phs_accession_gs:
        type: search_as_you_type
      study_name_gs:
        type: search_as_you_type
      study_data_types_gs:
        type: search_as_you_type
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (s:study)<--(:file)
      WITH DISTINCT s, {
        study_name: s.study_name,
        study_code: s.study_name,
        study_acronym: s.study_acronym,
        study_description: s.study_description,
        short_description: s.short_description,
        study_external_url: s.study_external_url,
        primary_investigator_name: s.primary_investigator_name,
        primary_investigator_email: s.primary_investigator_email,
        co_investigator_name: s.co_investigator_name,
        co_investigator_email: s.co_investigator_email,
        phs_accession: s.phs_accession,
        bioproject_accession: s.bioproject_accession,
        index_date: s.index_date,
        cds_requestor: s.cds_requestor,
        funding_agency: s.funding_agency,
        funding_source_program_name: s.funding_source_program_name,
        grant_id: s.grant_id,
        clinical_trial_system: s.clinical_trial_system,
        clinical_trial_identifier: s.clinical_trial_identifier,
        clinical_trial_arm: s.clinical_trial_arm,
        organism_species: s.organism_species,
        adult_or_childhood_study: s.adult_or_childhood_study,
        data_types: s.data_types,
        file_types: s.file_types,
        data_access_level: s.data_access_level,
        cds_primary_bucket: s.cds_primary_bucket,
        cds_secondary_bucket: s.cds_secondary_bucket,
        cds_tertiary_bucket: s.cds_tertiary_bucket,
        number_of_participants: s.number_of_participants,
        number_of_samples: s.number_of_samples,
        study_data_types: s.study_data_types,
        file_types_and_format: s.file_types_and_format,
        size_of_data_being_uploaded: s.size_of_data_being_uploaded,
        size_of_data_being_uploaded_unit: s.size_of_data_being_uploaded_unit,
        size_of_data_being_uploaded_original: s.size_of_data_being_uploaded_original,
        size_of_data_being_uploaded_original_unit: s.size_of_data_being_uploaded_original_unit,
        acl: s.acl,
        study_access: s.study_access,
        study_version: s.study_version,
        study_code_gs: s.study_name,
        phs_accession_gs: s.phs_accession,
        study_name_gs: s.study_name,
        study_data_types_gs: s.data_types
      } AS opensearch_data
      SKIP $skip LIMIT $limit
      OPTIONAL MATCH (s)<--(f:file)
      OPTIONAL MATCH (f)-->(p:participant)
      WITH s, 
        apoc.map.merge(opensearch_data, {
          number_of_participants: COUNT(DISTINCT p)
        }) AS opensearch_data
      OPTIONAL MATCH (s)<--(f:file)
      OPTIONAL MATCH (f)-->(p:participant)
      OPTIONAL MATCH (p)<--(samp:sample)
      WITH s, 
        apoc.map.merge(opensearch_data, {
          number_of_samples: COUNT(DISTINCT samp)
        }) AS opensearch_data
      RETURN opensearch_data
      ORDER BY opensearch_data.study_code
    "
  - index_name: diagnosis
    type: neo4j
    mapping:
      diagnosis_id:
        type: keyword
      disease_type:
        type: keyword
      vital_status:
        type: keyword
      primary_diagnosis:
        type: keyword
      primary_site:
        type: keyword
      age_at_diagnosis:
        type: keyword
      tumor_grade:
        type: keyword
      tumor_stage_clinical_m:
        type: keyword
      tumor_stage_clinical_n:
        type: keyword
      tumor_stage_clinical_t:
        type: keyword
      morphology:
        type: keyword
      incidence_type:
        type: keyword
      progression_or_recurrence:
        type: keyword
      days_to_recurrence:
        type: keyword
      days_to_last_followup:
        type: keyword
      last_known_disease_status:
        type: keyword
      days_to_last_known_status:
        type: keyword
    cypher_query: "
      MATCH (d:diagnosis)
      WITH DISTINCT d, {
        diagnosis_id: d.diagnosis_id,
        disease_type: d.disease_type,
        vital_status: d.vital_status,
        primary_diagnosis: TRIM(LAST(apoc.text.split(d.primary_diagnosis, ':'))),
        primary_site: d.primary_site,
        age_at_diagnosis: d.age_at_diagnosis,
        tumor_grade: d.tumor_grade,
        tumor_stage_clinical_m: d.tumor_stage_clinical_m,
        tumor_stage_clinical_n: d.tumor_stage_clinical_n,
        tumor_stage_clinical_t: d.tumor_stage_clinical_t,
        morphology: d.morphology,
        incidence_type: d.incidence_type,
        progression_or_recurrence: d.progression_or_recurrence,
        days_to_recurrence: d.days_to_recurrence,
        days_to_last_followup: d.days_to_last_followup,
        last_known_disease_status: d.last_known_disease_status,
        days_to_last_known_status: d.days_to_last_known_status
      } AS opensearch_data
      SKIP $skip LIMIT $limit
      RETURN opensearch_data
    "
  - index_name: genomic_info
    type: neo4j
    mapping:
      library_id:
        type: keyword
      bases:
        type: keyword
      number_of_reads:
        type: keyword
      avg_read_length:
        type: keyword
      coverage:
        type: keyword
      reference_genome_assembly:
        type: keyword
      custom_assembly_fasta_file_for_alignment:
        type: keyword
      design_description:
        type: keyword
      library_strategy:
        type: keyword
      library_layout:
        type: keyword
      library_source:
        type: keyword
      library_selection:
        type: keyword
      platform:
        type: keyword
      instrument_model:
        type: keyword
      sequence_alignment_software:
        type: keyword
    cypher_query: "
      MATCH (g:genomic_info)
      WITH DISTINCT g, {
        library_id: g.library_id,
        bases: g.bases,
        number_of_reads: g.number_of_reads,
        avg_read_length: g.avg_read_length,
        coverage: g.coverage,
        reference_genome_assembly: g.reference_genome_assembly,
        custom_assembly_fasta_file_for_alignment: g.custom_assembly_fasta_file_for_alignment,
        design_description: g.design_description,
        library_strategy: g.library_strategy,
        library_layout: g.library_layout,
        library_source: g.library_source,
        library_selection: g.library_selection,
        platform: g.platform,
        instrument_model: g.instrument_model,
        sequence_alignment_software: g.sequence_alignment_software
      } AS opensearch_data
      SKIP $skip LIMIT $limit
      RETURN opensearch_data
    "
  - index_name: specimen
    type: neo4j
    mapping:
      specimen_id:
        type: keyword
      participant:
        type: keyword
    cypher_query: "
      MATCH (spec:specimen)
      WITH DISTINCT spec, {
        specimen_id: spec.specimen_id,
        participant: spec.participant
      } AS opensearch_data
      SKIP $skip LIMIT $limit
      RETURN opensearch_data
    "
  - index_name: treatment
    type: neo4j
    mapping:
      treatment_id:
        type: keyword
      treatment_type:
        type: keyword
      treatment_outcome:
        type: keyword
      days_to_treatment:
        type: keyword
      therapeutic_agents:
        type: keyword
    cypher_query: "
      MATCH (t:treatment)
      WITH DISTINCT t, {
        treatment_id: t.treatment_id,
        treatment_type: t.treatment_type,
        treatment_outcome: t.treatment_outcome,
        days_to_treatment: t.days_to_treatment,
        therapeutic_agents: t.therapeutic_agents
      } AS opensearch_data
      SKIP $skip LIMIT $limit
      RETURN opensearch_data
    "
  - index_name: image
    type: neo4j
    mapping:
      study_link_id:
        type: keyword
      de_identification_method_type:
        type: keyword
      de_identification_method_description:
        type: keyword
      de_identification_software:
        type: keyword
      license:
        type: keyword
      citation_or_DOI:
        type: keyword
      species:
        type: keyword
      image_modality:
        type: keyword
      imaging_equipment_manufacturer:
        type: keyword
      imaging_equipment_model:
        type: keyword
      imaging_sofware:
        type: keyword
      imaging_protocol:
        type: keyword
      organ_or_tissue:
        type: keyword
      performed_imaging_study_description:
        type: keyword
      performed_imaging_study_admittingDiagnosisCode:
        type: keyword
      performed_imaging_study_nonAcquisitionModalitiesInStudyCode:
        type: keyword
      performed_imaging_study_lossyImageCompressionIndicator:
        type: keyword
      performed_imaging_study_summary:
        type: keyword
      performed_imaging_study_primaryAnatomicSiteCode:
        type: keyword
      performed_imaging_study_acquisitionTypeCode:
        type: keyword
      performed_imaging_study_imageTypeCode:
        type: keyword
      performed_imaging_study_cardiacSynchronizationTechniqueCode:
        type: keyword
      performed_imaging_study_dataCollectionDiameter:
        type: keyword
      performed_imaging_study_respiratoryMotionTechniqueCode:
        type: keyword
      performed_imaging_study_bodyPositionCode:
        type: keyword
      performed_imaging_study_typeCode:
        type: keyword
      performed_imaging_study_algorithmCode:
        type: keyword
      performed_imaging_study_reconstructionFieldOfViewHeight:
        type: keyword
      performed_imaging_study_reconstructionFieldOfViewWidth:
        type: keyword
      performed_imaging_study_reconstructionDiameter:
        type: keyword
      performed_imaging_study_sliceThickness:
        type: keyword
      performed_imaging_study_reconstructionInterval:
        type: keyword
      longitudinal_temporal_event_type:
        type: keyword
      longitudinal_temporal_event_offset:
        type: keyword
      CTAquisitionProtocolElement_singleCollimationWidth:
        type: keyword
      CTAquisitionProtocolElement_totalCollimationWidth:
        type: keyword
      CTAquisitionProtocolElement_gantryDetectorTilt:
        type: keyword
      CTAquisitionProtocolElement_tableSpeed:
        type: keyword
      CTAquisitionProtocolElement_spiralPitchFactor:
        type: keyword
      CTAquisitionProtocolElement_ctdiVol:
        type: keyword
      CTAquisitionProtocolElement_ctdiPhantomTypeCode:
        type: keyword
      CTAquisitionProtocolElement_kVp:
        type: keyword
      CTAquisitionProtocolElement_exposureModulationType_Code:
        type: keyword
      CTImageReconstructionProtocolElement_convolutionKernel:
        type: keyword
      CTImageReconstructionProtocolElement_convolutionKernelGroupCode:
        type: keyword
      MRImageAcquisitionProtocolElement_echoPulseSequenceCategoryCode:
        type: keyword
      MRImageAcquisitionProtocolElement_diffusionBValue:
        type: keyword
      MRImageAcquisitionProtocolElement_diffusionDirectionalityCode:
        type: keyword
      MRImageAcquisitionProtocolElement_magneticFieldStrength:
        type: keyword
      MRImageAcquisitionProtocolElement_resonantNucleusCode:
        type: keyword
      MRImageAcquisitionProtocolElement_acquisitionContrastCode:
        type: keyword
      MRImageAcquisitionProtocolElement_inversionRecoveryIndicator:
        type: keyword
      MRImageAcquisitionProtocolElement_pulseSequenceName:
        type: keyword
      MRImageAcquisitionProtocolElement_multipleSpinEchoIndicator:
        type: keyword
      MRImageAcquisitionProtocolElement_phaseContrastIndicator:
        type: keyword
      MRImageAcquisitionProtocolElement_timeOfFlightContrastIndicator:
        type: keyword
      MRImageAcquisitionProtocolElement_arterialSpinLabelingContrastCode:
        type: keyword
      MRImageAcquisitionProtocolElement_steadyStatePulseSequenceCode:
        type: keyword
      MRImageAcquisitionProtocolElement_echoPlanarPulseSequenceIndicator:
        type: keyword
      MRImageAcquisitionProtocolElement_saturationRecoveryIndicator:
        type: keyword
      MRImageAcquisitionProtocolElement_spectrallySelectedSuppressionCode:
        type: keyword
      MRImageReconstructionProtocolElement_complexImageComponentCode:
        type: keyword
      PETImagingAcquisitionProtocolElement_gantryDetectorTilt:
        type: keyword
      Radiopharmaceutical_radionuclideCode:
        type: keyword
      acquisition_method_type:
        type: keyword
      tumor_tissue_type:
        type: keyword
      tissue_fixative:
        type: keyword
      embedding_medium:
        type: keyword
      staining_method:
        type: keyword
      objective:
        type: keyword
      nominal_magnification:
        type: keyword
      immersion:
        type: keyword
      lens_numerical_aperture:
        type: keyword
      working_distance:
        type: keyword
      imaging_assay_type:
        type: keyword
      pyramid:
        type: keyword
      physical_size_x:
        type: keyword
      physical_size_y:
        type: keyword
      physical_size_z:
        type: keyword
      size_c:
        type: keyword
      size_t:
        type: keyword
      size_x:
        type: keyword
      size_y:
        type: keyword
      size_z:
        type: keyword
      channel_metadata_filename:
        type: keyword
      channel_metadata_file_url_in_cds:
        type: keyword
      channel_id:
        type: keyword
      channel_name:
        type: keyword
      cycle_number:
        type: keyword
      sub_cycle_number:
        type: keyword
      target_name:
        type: keyword
      antibody_name:
        type: keyword
      rrid_identifier:
        type: keyword
      fluorophore:
        type: keyword
      clone:
        type: keyword
      lot:
        type: keyword
      vendor:
        type: keyword
      catalog_number:
        type: keyword
      excitation_wavelength:
        type: keyword
      emission_wavelength:
        type: keyword
      excitation_bandwidth:
        type: keyword
      emission_bandwidth:
        type: keyword
      metal_isotope_element:
        type: keyword
      oligo_barcode_upper_strand:
        type: keyword
      oligo_barcode_lower_strand:
        type: keyword
      diluation:
        type: keyword
      concentration:
        type: keyword
      passes_qc:
        type: keyword
      crdc_id:
        type: keyword
    cypher_query: "
      MATCH (i:image)
      WITH DISTINCT i, {
        study_link_id: i.study_link_id,
        de_identification_method_type: i.de_identification_method_type,
        de_identification_method_description: i.de_identification_method_description,
        de_identification_software: i.de_identification_software,
        license: i.license,
        citation_or_DOI: i.citation_or_DOI,
        species: i.species,
        image_modality: i.image_modality,
        imaging_equipment_manufacturer: i.imaging_equipment_manufacturer,
        imaging_equipment_model: i.imaging_equipment_model,
        imaging_sofware: i.imaging_sofware,
        imaging_protocol: i.imaging_protocol,
        organ_or_tissue: i.organ_or_tissue,
        performed_imaging_study_description: i.performed_imaging_study_description,
        performed_imaging_study_admittingDiagnosisCode: i.performed_imaging_study_admittingDiagnosisCode,
        performed_imaging_study_nonAcquisitionModalitiesInStudyCode: i.performed_imaging_study_nonAcquisitionModalitiesInStudyCode,
        performed_imaging_study_lossyImageCompressionIndicator: i.performed_imaging_study_lossyImageCompressionIndicator,
        performed_imaging_study_summary: i.performed_imaging_study_summary,
        performed_imaging_study_primaryAnatomicSiteCode: i.performed_imaging_study_primaryAnatomicSiteCode,
        performed_imaging_study_acquisitionTypeCode: i.performed_imaging_study_acquisitionTypeCode,
        performed_imaging_study_imageTypeCode: i.performed_imaging_study_imageTypeCode,
        performed_imaging_study_cardiacSynchronizationTechniqueCode: i.performed_imaging_study_cardiacSynchronizationTechniqueCode,
        performed_imaging_study_dataCollectionDiameter: i.performed_imaging_study_dataCollectionDiameter,
        performed_imaging_study_respiratoryMotionTechniqueCode: i.performed_imaging_study_respiratoryMotionTechniqueCode,
        performed_imaging_study_bodyPositionCode: i.performed_imaging_study_bodyPositionCode,
        performed_imaging_study_typeCode: i.performed_imaging_study_typeCode,
        performed_imaging_study_algorithmCode: i.performed_imaging_study_algorithmCode,
        performed_imaging_study_reconstructionFieldOfViewHeight: i.performed_imaging_study_reconstructionFieldOfViewHeight,
        performed_imaging_study_reconstructionFieldOfViewWidth: i.performed_imaging_study_reconstructionFieldOfViewWidth,
        performed_imaging_study_reconstructionDiameter: i.performed_imaging_study_reconstructionDiameter,
        performed_imaging_study_sliceThickness: i.performed_imaging_study_sliceThickness,
        performed_imaging_study_reconstructionInterval: i.performed_imaging_study_reconstructionInterval,
        longitudinal_temporal_event_type: i.longitudinal_temporal_event_type,
        longitudinal_temporal_event_offset: i.longitudinal_temporal_event_offset,
        CTAquisitionProtocolElement_singleCollimationWidth: i.CTAquisitionProtocolElement_singleCollimationWidth,
        CTAquisitionProtocolElement_totalCollimationWidth: i.CTAquisitionProtocolElement_totalCollimationWidth,
        CTAquisitionProtocolElement_gantryDetectorTilt: i.CTAquisitionProtocolElement_gantryDetectorTilt,
        CTAquisitionProtocolElement_tableSpeed: i.CTAquisitionProtocolElement_tableSpeed,
        CTAquisitionProtocolElement_spiralPitchFactor: i.CTAquisitionProtocolElement_spiralPitchFactor,
        CTAquisitionProtocolElement_ctdiVol: i.CTAquisitionProtocolElement_ctdiVol,
        CTAquisitionProtocolElement_ctdiPhantomTypeCode: i.CTAquisitionProtocolElement_ctdiPhantomTypeCode,
        CTAquisitionProtocolElement_kVp: i.CTAquisitionProtocolElement_kVp,
        CTAquisitionProtocolElement_exposureModulationType_Code: i.CTAquisitionProtocolElement_exposureModulationType_Code,
        CTImageReconstructionProtocolElement_convolutionKernel: i.CTImageReconstructionProtocolElement_convolutionKernel,
        CTImageReconstructionProtocolElement_convolutionKernelGroupCode: i.CTImageReconstructionProtocolElement_convolutionKernelGroupCode,
        MRImageAcquisitionProtocolElement_echoPulseSequenceCategoryCode: i.MRImageAcquisitionProtocolElement_echoPulseSequenceCategoryCode,
        MRImageAcquisitionProtocolElement_diffusionBValue: i.MRImageAcquisitionProtocolElement_diffusionBValue,
        MRImageAcquisitionProtocolElement_diffusionDirectionalityCode: i.MRImageAcquisitionProtocolElement_diffusionDirectionalityCode,
        MRImageAcquisitionProtocolElement_magneticFieldStrength: i.MRImageAcquisitionProtocolElement_magneticFieldStrength,
        MRImageAcquisitionProtocolElement_resonantNucleusCode: i.MRImageAcquisitionProtocolElement_resonantNucleusCode,
        MRImageAcquisitionProtocolElement_acquisitionContrastCode: i.MRImageAcquisitionProtocolElement_acquisitionContrastCode,
        MRImageAcquisitionProtocolElement_inversionRecoveryIndicator: i.MRImageAcquisitionProtocolElement_inversionRecoveryIndicator,
        MRImageAcquisitionProtocolElement_pulseSequenceName: i.MRImageAcquisitionProtocolElement_pulseSequenceName,
        MRImageAcquisitionProtocolElement_multipleSpinEchoIndicator: i.MRImageAcquisitionProtocolElement_multipleSpinEchoIndicator,
        MRImageAcquisitionProtocolElement_phaseContrastIndicator: i.MRImageAcquisitionProtocolElement_phaseContrastIndicator,
        MRImageAcquisitionProtocolElement_timeOfFlightContrastIndicator: i.MRImageAcquisitionProtocolElement_timeOfFlightContrastIndicator,
        MRImageAcquisitionProtocolElement_arterialSpinLabelingContrastCode: i.MRImageAcquisitionProtocolElement_arterialSpinLabelingContrastCode,
        MRImageAcquisitionProtocolElement_steadyStatePulseSequenceCode: i.MRImageAcquisitionProtocolElement_steadyStatePulseSequenceCode,
        MRImageAcquisitionProtocolElement_echoPlanarPulseSequenceIndicator: i.MRImageAcquisitionProtocolElement_echoPlanarPulseSequenceIndicator,
        MRImageAcquisitionProtocolElement_saturationRecoveryIndicator: i.MRImageAcquisitionProtocolElement_saturationRecoveryIndicator,
        MRImageAcquisitionProtocolElement_spectrallySelectedSuppressionCode: i.MRImageAcquisitionProtocolElement_spectrallySelectedSuppressionCode,
        MRImageReconstructionProtocolElement_complexImageComponentCode: i.MRImageReconstructionProtocolElement_complexImageComponentCode,
        PETImagingAcquisitionProtocolElement_gantryDetectorTilt: i.PETImagingAcquisitionProtocolElement_gantryDetectorTilt,
        Radiopharmaceutical_radionuclideCode: i.Radiopharmaceutical_radionuclideCode,
        acquisition_method_type: i.acquisition_method_type,
        tumor_tissue_type: i.tumor_tissue_type,
        tissue_fixative: i.tissue_fixative,
        embedding_medium: i.embedding_medium,
        staining_method: i.staining_method,
        objective: i.objective,
        nominal_magnification: i.nominal_magnification,
        immersion: i.immersion,
        lens_numerical_aperture: i.lens_numerical_aperture,
        working_distance: i.working_distance,
        imaging_assay_type: i.imaging_assay_type,
        pyramid: i.pyramid,
        physical_size_x: i.physical_size_x,
        physical_size_y: i.physical_size_y,
        physical_size_z: i.physical_size_z,
        size_c: i.size_c,
        size_t: i.size_t,
        size_x: i.size_x,
        size_y: i.size_y,
        size_z: i.size_z,
        channel_metadata_filename: i.channel_metadata_filename,
        channel_metadata_file_url_in_cds: i.channel_metadata_file_url_in_cds,
        channel_id: i.channel_id,
        channel_name: i.channel_name,
        cycle_number: i.cycle_number,
        sub_cycle_number: i.sub_cycle_number,
        target_name: i.target_name,
        antibody_name: i.antibody_name,
        rrid_identifier: i.rrid_identifier,
        fluorophore: i.fluorophore,
        clone: i.clone,
        lot: i.lot,
        vendor: i.vendor,
        catalog_number: i.catalog_number,
        excitation_wavelength: i.excitation_wavelength,
        emission_wavelength: i.emission_wavelength,
        excitation_bandwidth: i.excitation_bandwidth,
        emission_bandwidth: i.emission_bandwidth,
        metal_isotope_element: i.metal_isotope_element,
        oligo_barcode_upper_strand: i.oligo_barcode_upper_strand,
        oligo_barcode_lower_strand: i.oligo_barcode_lower_strand,
        diluation: i.diluation,
        concentration: i.concentration,
        passes_qc: i.passes_qc,
        crdc_id: i.crdc_id
      } AS opensearch_data
      SKIP $skip LIMIT $limit
      RETURN opensearch_data
    "
  # Subject IDs index
  - index_name: subject_ids
    type: neo4j
    # type mapping for each property of the index
    mapping:
      phs_accession:
        type: keyword
      subject_id:
        type: keyword
      # subject_ids must be converted into lower case
      subject_ids:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (s:study)<--(:file)-->(p:participant)
      WITH DISTINCT p, s
      SKIP $skip LIMIT $limit
      RETURN
        s.phs_accession AS phs_accession,
        p.participant_id AS subject_id,
        toLower(p.participant_id) AS subject_ids
    "
  - index_name: program_detail
    type: neo4j
    # type mapping for each property of the index
    mapping:
      program:
        type: keyword
      program_name:
        type: keyword
      program_url:
        type: keyword
      program_short_description:
        type: keyword
      num_studies:
        type: integer
      num_participants:
        type: integer
      num_files:
        type: integer
      num_samples:
        type: integer
      num_disease_sites:
        type: integer
      study_participants:
        type: nested
        properties:
          group:
            type: keyword
          subjects:
            type: integer
      studies:
        type: nested
        properties:
          accession:
            type: keyword
          study_access:
            type: keyword
          study_version:
            type: keyword
          study_data_types:
            type: keyword
          study_name:
            type: keyword
          study_description:
            type: keyword
          short_description:
            type: keyword
          num_participants:
            type: integer
          num_samples:
            type: integer
          num_files:
            type: integer
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (pr:program)
      OPTIONAL MATCH (pr)<--(s:study)
      WITH s
      OPTIONAL MATCH (s)<--(p:participant)
      WITH s, count(distinct p) as num_participants
      WITH s,
          {
              group: s.study_name,
              subjects: num_participants
          } AS study_participants,
          {
              accession: s.phs_accession,
              study_access: s.study_access,
              study_version: s.study_version,
              study_data_types: s.study_data_types,
              study_name: s.study_name,
              study_description: s.study_description,
              short_description: s.short_description,
              num_participants: num_participants
          } AS studies
      OPTIONAL MATCH (s)<--(:participant)<--(samp:sample)
      WITH s, study_participants,
          apoc.map.merge(studies, {
              num_samples: count(distinct samp)
          }) AS studies
      OPTIONAL MATCH (s)<--(f:file)
      WITH s, study_participants,
          apoc.map.merge(studies, {
              num_files: count(distinct f)
          }) AS studies
      OPTIONAL MATCH (pr:program)<--(s)
      WITH pr, {
          program: pr.program_acronym,
          program_name: pr.program_name,
          program_url: pr.program_external_url,
          program_short_description: pr.program_short_description,
          num_studies: COUNT(DISTINCT s),
          studies: collect(distinct studies),
          study_participants: collect(distinct study_participants)
      } as output
      OPTIONAL MATCH (pr)<--(:study)<--(p:participant)
      WITH pr,
          apoc.map.merge(output, {
              num_participants: count(distinct p)
          }) as output
      OPTIONAL MATCH (pr)<--(:study)<--(:participant)<--(samp:sample)
      WITH pr,
          apoc.map.merge(output, {
              num_samples: count(distinct samp)
          }) as output
      OPTIONAL MATCH (pr)<--(:study)<--(f:file)
      WITH pr,
          apoc.map.merge(output, {
              num_files: count(distinct f)
          }) as output
      OPTIONAL MATCH (pr)<--(:study)<--(:participant)<--(diag:diagnosis)
      WITH pr,
          apoc.map.merge(output, {
              num_disease_sites: COUNT(DISTINCT diag.primary_site)
          }) as output
      RETURN 
        output.program AS program,
        output.program_name AS program_name,
        output.program_url AS program_url,
        output.program_short_description AS program_short_description,
        output.num_studies AS num_studies,
        output.num_participants AS num_participants,
        output.num_files AS num_files,
        output.num_samples AS num_samples,
        output.num_disease_sites AS num_disease_sites,
        output.study_participants AS study_participants,
        output.studies AS studies
  "
  - index_name: program_list
    type: neo4j
    # type mapping for each property of the index
    mapping:
      acronym:
        type: keyword
      name:
        type: keyword
      website:
        type: keyword
      num_studies:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (pr:program)
      OPTIONAL MATCH (pr)<--(s:study)
      RETURN DISTINCT
        pr.program_acronym AS acronym,
        pr.program_name AS name,
        pr.program_external_url AS website,
        COUNT(DISTINCT s) AS num_studies
    "
  - index_name: study_list
    type: neo4j
    mapping:
      phs_accession:
        type: keyword
      study_name:
        type: keyword
      data_type:
        type: keyword
      study_access:
        type: keyword
      numberOfSubjects:
        type: keyword
      numberOfFiles:
        type: keyword
      study_version:
        type: keyword
    cypher_query: "
      MATCH (s:study)
      OPTIONAL MATCH (p:participant)-->(s)
      WITH s, count(distinct p) AS num_participants
      OPTIONAL MATCH (f:file)-->(s)
      WITH s, num_participants, count(distinct f) as num_files
      RETURN 
        s.phs_accession AS phs_accession,
        s.study_name AS study_name,
        s.study_data_types AS data_type,
        s.study_access AS study_access,
        num_participants AS numberOfSubjects,
        num_files AS numberOfFiles,
        s.study_version AS study_version
    "
  - index_name: study_detail
    type: neo4j
    mapping:
      study_name:
        type: keyword
      phs_accession:
        type: keyword
      study_acronym:
        type: keyword
      study_description:
        type: keyword
      study_version:
        type: keyword
      study_access:
        type: keyword
      data_types:
        type: keyword
      study_external_url:
        type: keyword
      numberOfSubjects:
        type: keyword
      numberOfSamples:
        type: keyword
      numberOfDiseaseSites:
        type: keyword
      numberOfFiles:
        type: keyword
    cypher_query: "
      MATCH (s:study)
      WITH s, {
          study_name: s.study_name,
          phs_accession: s.phs_accession,
          study_acronym: s.study_acronym,
          study_description: s.study_description,
          data_types: s.study_data_types,
          study_external_url: s.study_external_url,
          study_version: s.study_version,
          study_access: s.data_access_level
      } AS opensearch_data
      OPTIONAL MATCH (s)<--(p:participant)
      WITH s,
          apoc.map.merge(opensearch_data, {
              numberOfSubjects: COUNT(DISTINCT p)
          }) AS opensearch_data
      OPTIONAL MATCH (s)<--(:participant)<--(samp:sample)
      WITH s,
          apoc.map.merge(opensearch_data, {
              numberOfSamples: COUNT(DISTINCT samp)
          }) AS opensearch_data
      OPTIONAL MATCH (s)<--(:participant)<--(diag:diagnosis)
      WITH s,
          apoc.map.merge(opensearch_data, {
              numberOfDiseaseSites: COUNT(DISTINCT diag.primary_site)
          }) AS opensearch_data
      OPTIONAL MATCH (s)<--(f:file)
      WITH s,
          apoc.map.merge(opensearch_data, {
              numberOfFiles: COUNT(DISTINCT f)
          }) AS opensearch_data
      RETURN opensearch_data
    "
  - index_name: subject_detail
    type: neo4j
    mapping:
      subject_id:
        type: keyword
      study_acronym:
        type: keyword
      study_name:
        type: keyword
      gender:
        type: keyword
      site:
        type: keyword
      numberOfSamples:
        type: keyword
      numberOfDiseaseSites:
        type: keyword
      numberOfFiles:
        type: keyword
      files:
        type: nested
        properties:
          file_id:
            type: keyword
          file_name:
            type: keyword
          file_type:
            type: keyword
          file_description:
            type: keyword
          file_size:
            type: keyword
          md5sum:
            type: keyword
          file_url_in_cds:
            type: keyword
          experimental_strategy_and_data_subtypes:
            type: keyword
      samples:
        type: nested
        properties:
          sample_id:
            type: keyword
          sample_type:
            type: keyword
          sample_tumor_status:
            type: keyword
          sample_anatomic_site:
            type: keyword
          sample_age_at_collection:
            type: integer
          derived_from_specimen:
            type: keyword
          biosample_accession:
            type: keyword
    cypher_query: "
      MATCH (p:participant)
      WITH p
      SKIP $skip LIMIT $limit
      OPTIONAL MATCH (s:study)<--(p)
      WITH p, {
          subject_id: p.participant_id,
          study_acronym: s.study_acronym,
          study_name: s.study_name,
          gender: p.gender
      } AS opensearch_data
      OPTIONAL MATCH (p)<--(samp:sample)
      WITH p,
          apoc.map.merge(opensearch_data, {
              site: COLLECT(DISTINCT TRIM(LAST(apoc.text.split(samp.sample_anatomic_site, ':')))),
              samples: CASE WHEN samp IS NOT NULL THEN COLLECT(DISTINCT {
                sample_id: samp.sample_id,
                sample_type: TRIM(LAST(apoc.text.split(samp.sample_type, ':'))),
                sample_tumor_status: samp.sample_tumor_status,
                sample_anatomic_site: TRIM(LAST(apoc.text.split(samp.sample_anatomic_site, ':'))),
                sample_age_at_collection: samp.sample_age_at_collection,
                derived_from_specimen: samp.derived_from_specimen,
                biosample_accession: samp.biosample_accession
              }) ELSE NULL END
          }) AS opensearch_data
      OPTIONAL MATCH (p)<--(diag:diagnosis)
      WITH p,
          apoc.map.merge(opensearch_data, {
              numberOfDiseaseSites: COUNT(DISTINCT diag.primary_site)
          }) AS opensearch_data
      OPTIONAL MATCH (p)<--(samp)<--(f:file)
      WITH p,
        apoc.map.merge(opensearch_data, {
            files: CASE WHEN f IS NOT NULL THEN COLLECT(DISTINCT {
              file_id: f.file_id,
              file_name: f.file_name,
              file_type: f.file_type,
              file_description: f.file_description,
              file_size: f.file_size,
              md5sum: f.md5sum,
              file_url_in_cds: f.file_url_in_cds,
              experimental_strategy_and_data_subtypes: f.experimental_strategy_and_data_subtypes
            }) ELSE NULL END
        }) AS opensearch_data
      WITH p, 
        apoc.map.merge(opensearch_data, {
            numberOfFiles: size(opensearch_data.files),
            numberOfSamples: COUNT(DISTINCT opensearch_data.samples)
        }) AS opensearch_data
      RETURN opensearch_data
    "
  - index_name: subject_ids_list
    type: neo4j
    # type mapping for each property of the index
    mapping:
      subjectIds:
        type: keyword
    # Cypher query will be used to retrieve data from Neo4j, and index into Elasticsearch
    cypher_query: "
      MATCH (p:participant)-->(s:study)
      RETURN
      COLLECT(DISTINCT p.participant_id) AS subjectIds
    "
  # About Page index
  - index_name: about_page
    type: about_file
    # type mapping for each property of the index
    mapping:
      page:
        type: search_as_you_type
      title:
        type: search_as_you_type
      primaryContentImage:
        type: text
      content:
        type: object
  # Model nodes index
  - index_name: model_nodes
    type: model
    subtype: node
    # type mapping for each property of the index
    mapping:
      node:
        type: search_as_you_type
      node_kw:
        type: keyword
  # Model properties index
  - index_name: model_properties
    type: model
    subtype: property
    # type mapping for each property of the index
    mapping:
      node:
        type: search_as_you_type
      property:
        type: search_as_you_type
      property_kw:
        type: keyword
      property_description:
        type: search_as_you_type
      property_required:
        type: search_as_you_type
      property_type:
        type: search_as_you_type
  # Model values index
  - index_name: model_values
    type: model
    subtype: value
    # type mapping for each property of the index
    mapping:
      node:
        type: search_as_you_type
      property:
        type: search_as_you_type
      property_description:
        type: search_as_you_type
      property_required:
        type: search_as_you_type
      property_type:
        type: search_as_you_type
      value:
        type: search_as_you_type
      value_kw:
        type: keyword
